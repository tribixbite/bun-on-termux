#!/data/data/com.termux/files/usr/bin/bash
# Enhanced Bunx wrapper for Termux - implements temporary package execution like npx
# Uses isolated temporary directory, removes after execution

# Function to run package with proper temporary execution
run_package() {
    local package="$1"
    shift
    
    # Store the original working directory
    local original_dir="$(pwd)"
    
    # Extract package name for binary detection
    local package_name=$(echo "$package" | sed 's/@[^/]*$//' | sed 's/.*\///')
    local binary_name="$package_name"
    
    # Handle special package to binary mappings
    case "$package_name" in
        "typescript")
            binary_name="tsc"
            ;;
        *)
            binary_name="$package_name"
            ;;
    esac
    
    # First, try to find existing binary in PATH
    if command -v "$binary_name" >/dev/null 2>&1; then
        exec "$binary_name" "$@"
    fi
    
    # Create unique temporary directory for this execution
    local temp_id="$$-$(date +%s)"
    local temp_dir="$HOME/.bun/tmp/bunx-temp-$temp_id"
    
    # Function to cleanup on exit
    cleanup() {
        if [ -d "$temp_dir" ]; then
            rm -rf "$temp_dir" 2>/dev/null || true
        fi
    }
    
    # Ensure cleanup happens on script exit
    trap cleanup EXIT INT TERM
    
    # Create temporary directory and package.json
    mkdir -p "$temp_dir"
    cd "$temp_dir"
    echo '{}' > package.json
    
    # Install package temporarily using bun add
    if bun add "$package" --backend=copyfile --no-summary 2>/dev/null; then
        # Change back to original directory before running the binary
        cd "$original_dir"
        
        # Try to run the binary from the original directory
        local bin_path="$temp_dir/node_modules/.bin/$binary_name"
        local exit_code=0
        
        if [ -x "$bin_path" ]; then
            "$bin_path" "$@"
            exit_code=$?
        elif [ -x "$temp_dir/node_modules/.bin/$package_name" ]; then
            "$temp_dir/node_modules/.bin/$package_name" "$@"
            exit_code=$?
        else
            # Look for any executable in the bin directory
            if [ -d "$temp_dir/node_modules/.bin" ]; then
                local first_bin=$(find "$temp_dir/node_modules/.bin" -type f -executable | head -1)
                if [ -n "$first_bin" ]; then
                    "$first_bin" "$@"
                    exit_code=$?
                else
                    echo "Error: No executable found for package '$package'"
                    cleanup
                    exit 1
                fi
            else
                echo "Error: Could not find bin directory for package '$package'"
                cleanup
                exit 1
            fi
        fi
        
        # Explicit cleanup and exit with the binary's exit code
        cleanup
        exit $exit_code
    else
        echo "Error: Failed to install package '$package'"
        cleanup
        exit 1
    fi
}

# Handle help and flags first
if [ -z "$1" ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    echo "Usage: bunx [flags] <package><@version> [flags and arguments for the package]"
    echo "Execute an npm package executable (CLI), automatically installing into a global shared cache if not installed in node_modules."
    echo ""
    echo "Flags:"
    echo "  --bun      Force the command to run with Bun instead of Node.js"
    echo ""
    echo "Examples:"
    echo "  bunx prisma migrate"
    echo "  bunx prettier foo.js"
    echo "  bunx --bun vite dev foo.js"
    exit 0
fi

# Handle --bun flag (for now, just ignore it as we're already using bun)
if [ "$1" = "--bun" ]; then
    shift
    # Check if we have a package name after removing --bun
    if [ -z "$1" ]; then
        echo "Error: Package name required after --bun flag"
        exit 1
    fi
fi

# Run the package
run_package "$@"
